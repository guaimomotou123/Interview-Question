# **栈（stack）和堆（heap）的具体区别** 

### 1、在申请方式上 

**栈**（stack）: 现在很多人都称之为堆栈，这个时候实际上还是指的栈。它由编译器自动管理，无需我们手工控制。 例如，声明函数中的一个局部变量 int b 系统自动在栈中为b开辟空间；在调用一个函数时，系统自动的给函数的形参变量在栈中开辟空间。 

**堆**（heap）: 申请和释放由程序员控制，并指明大小。容易产生memory leak。 

在C中使用malloc函数。 

如：char  *p1 = (char *)malloc(10); 

在C++中用new运算符。 

如：char  *p2 = new char(20); 

但是注意p1本身在全局区，而p2本身是在栈中的，只是它们指向的空间是在堆中。 

### 2、申请后系统的响应上 

**栈**（stack）:只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 

**堆**（heap）: 首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete或 free语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 

### 3、申请大小的限制 

**栈**（stack）:在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：打开工程，依次操作菜单如下：Project->Setting->Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。 

注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。 

**堆**（heap）: 堆是向高地址扩展的数据结构，是不连续的内存区域（空闲部分用链表串联起来）。正是由于系统是用链表来存储空闲内存，自然是不连续的，而链表的遍历方向是由低地址向高地址。一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。由此可见，堆获得的空间比较灵活，也比较大。 

### 4、分配空间的效率上 

**栈**（stack）:栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。但程序员无法对其进行控制。 

**堆**（heap）:是C/C++函数库提供的，由new或malloc分配的内存，一般速度比较慢，而且容易产生内存碎片。它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。这样可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。显然，堆的效率比栈要低得多。

###  5、堆和栈中的存储内容 

**栈**（stack）:在函数调用时，第一个进栈的是主函数中子函数调用后的下一条指令（子函数调用语句的下一条可执行语句）的地址，然后是子函数的各个形参。在大多数的C编译器中，参数是由右往左入栈的，然后是子函数中的局部变量。

注意：静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中子函数调用完成的下一条指令，程序由该点继续运行。 

**堆**（heap）:一般是在堆的头部用一个字节存放堆的大小，堆中的具体内容有程序员安排。 

### 6、存取效率的比较 

这个应该是显而易见的。拿栈上的数组和堆上的数组来说： 

```
void main()
{
	int arr[5] = { 1,2,3,4,5 };
	int *arr1 = NULL；
	arr1 = new int[5];
	for (int j = 0;j <= 4;j++)
	{
		arr1[j] = j + 6;
	}
	int a = arr[1];
	int b = arr1[1];
}
```

上面代码中，arr1（局部变量）是在栈中，但是指向的空间确在堆上，两者的存取效率，当然是arr高。因为arr[1]可以直接访问，但是访问arr1[1]，首先要访问数组的起始地址arr1，然后才能访问到arr1[1]。 

总而言之，言而总之：

 堆和栈的区别可以用如下的比喻来看出： 使用栈就象我们去饭馆里吃饭，只管点菜（声明变量）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 

使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 

此文章转载自：https://www.xuebuyuan.com/3183621.html